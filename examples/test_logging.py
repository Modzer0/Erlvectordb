#!/usr/bin/env python3

"""
Tests for logging functionality

This module contains both property-based tests and unit tests for the logging
functionality to ensure all logs go to stderr and never to stdout.
"""

import json
import io
import sys
import os
import logging
from typing import Dict, Any
from hypothesis import given, strategies as st, settings
import pytest

# Import the server components
sys.path.insert(0, os.path.dirname(__file__))
from gemini_mcp_server import (
    MCPServer, ServerConfig, SocketHandler, OAuthManager, 
    RequestRouter, StdioHandler, logger
)


# ============================================================================
# Property-Based Tests
# ============================================================================

# Feature: gemini-mcp-server-fix, Property 10: Stderr-only logging
@given(
    log_message=st.text(min_size=1, max_size=500),
    log_level=st.sampled_from(['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'])
)
@settings(max_examples=100, deadline=3000)
def test_stderr_only_logging_property(log_message: str, log_level: str):
    """
    Property 10: Stderr-only logging
    
    For any log message generated by the server, the message should be 
    written to stderr and never to stdout.
    
    Validates: Requirements 4.1, 7.4
    """
    # Create mock streams to capture output
    mock_stdout = io.StringIO()
    mock_stderr = io.StringIO()
    
    # Save original streams
    original_stdout = sys.stdout
    original_stderr = sys.stderr
    
    try:
        # Redirect streams
        sys.stdout = mock_stdout
        sys.stderr = mock_stderr
        
        # Create a new logger with stderr handler
        test_logger = logging.getLogger(f'test_logger_{id(log_message)}')
        test_logger.setLevel(logging.DEBUG)
        test_logger.handlers = []  # Clear any existing handlers
        
        # Add handler that writes to stderr
        handler = logging.StreamHandler(sys.stderr)
        handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        test_logger.addHandler(handler)
        
        # Log the message at the specified level
        log_func = getattr(test_logger, log_level.lower())
        log_func(log_message)
        
        # Get captured output
        stdout_content = mock_stdout.getvalue()
        stderr_content = mock_stderr.getvalue()
        
        # Verify log message is in stderr
        assert log_message in stderr_content, \
            f"Log message should appear in stderr"
        
        # Verify log message is NOT in stdout
        assert log_message not in stdout_content, \
            f"Log message should NOT appear in stdout"
        
        # Verify stdout is empty (no log output)
        assert stdout_content == '', \
            f"stdout should be empty, but contains: {stdout_content}"
        
        # Verify stderr contains the log level
        assert log_level in stderr_content, \
            f"Log level {log_level} should appear in stderr"
    
    finally:
        # Restore original streams
        sys.stdout = original_stdout
        sys.stderr = original_stderr


# ============================================================================
# Unit Tests
# ============================================================================

class TestLoggingConfiguration:
    """Unit tests for logging configuration"""
    
    def test_error_logging_to_stderr(self):
        """Test error logging to stderr"""
        # Create mock stderr
        mock_stderr = io.StringIO()
        
        # Create a test logger
        test_logger = logging.getLogger('test_error_logger')
        test_logger.setLevel(logging.ERROR)
        test_logger.handlers = []
        
        # Add handler for stderr
        handler = logging.StreamHandler(mock_stderr)
        handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        test_logger.addHandler(handler)
        
        # Log an error
        error_message = "Test error message"
        test_logger.error(error_message)
        
        # Verify error is in stderr
        stderr_content = mock_stderr.getvalue()
        assert error_message in stderr_content
        assert 'ERROR' in stderr_content
    
    def test_startup_logging(self):
        """Test startup logging"""
        # Create mock stderr
        mock_stderr = io.StringIO()
        
        # Create a test logger
        test_logger = logging.getLogger('test_startup_logger')
        test_logger.setLevel(logging.INFO)
        test_logger.handlers = []
        
        # Add handler for stderr
        handler = logging.StreamHandler(mock_stderr)
        handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        test_logger.addHandler(handler)
        
        # Simulate startup logging
        config = ServerConfig()
        test_logger.info(f"ErlVectorDB MCP Server for Gemini CLI")
        test_logger.info(f"Target: {config.erlvectordb_host}:{config.erlvectordb_port}")
        test_logger.info(f"OAuth: {config.oauth_host}:{config.oauth_port}")
        
        # Verify startup messages are in stderr
        stderr_content = mock_stderr.getvalue()
        assert "ErlVectorDB MCP Server" in stderr_content
        assert "Target:" in stderr_content
        assert "OAuth:" in stderr_content
    
    def test_request_response_logging(self):
        """Test request/response logging"""
        # Create mock stderr
        mock_stderr = io.StringIO()
        
        # Create a test logger
        test_logger = logging.getLogger('test_request_logger')
        test_logger.setLevel(logging.DEBUG)
        test_logger.handlers = []
        
        # Add handler for stderr
        handler = logging.StreamHandler(mock_stderr)
        handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        test_logger.addHandler(handler)
        
        # Simulate request/response logging
        request_id = 123
        method = "tools/list"
        test_logger.debug(f"Read request line: 100 bytes")
        test_logger.info(f"Routing request: method={method}, id={request_id}")
        test_logger.debug(f"Wrote response: 200 bytes")
        
        # Verify request/response messages are in stderr
        stderr_content = mock_stderr.getvalue()
        assert "Read request line" in stderr_content
        assert "Routing request" in stderr_content
        assert "Wrote response" in stderr_content
        assert method in stderr_content
    
    def test_stdout_never_contains_log_messages(self):
        """Test that stdout never contains log messages"""
        # Create mock streams
        mock_stdout = io.StringIO()
        mock_stderr = io.StringIO()
        
        # Save original streams
        original_stdout = sys.stdout
        original_stderr = sys.stderr
        
        try:
            # Redirect streams
            sys.stdout = mock_stdout
            sys.stderr = mock_stderr
            
            # Create a test logger configured like the main logger
            test_logger = logging.getLogger('test_stdout_logger')
            test_logger.setLevel(logging.INFO)
            test_logger.handlers = []
            
            # Add handler that writes to stderr (like the main logger)
            handler = logging.StreamHandler(sys.stderr)
            handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
            test_logger.addHandler(handler)
            
            # Log various messages
            test_logger.debug("Debug message")
            test_logger.info("Info message")
            test_logger.warning("Warning message")
            test_logger.error("Error message")
            test_logger.critical("Critical message")
            
            # Get captured output
            stdout_content = mock_stdout.getvalue()
            stderr_content = mock_stderr.getvalue()
            
            # Verify stdout is empty
            assert stdout_content == '', \
                f"stdout should be empty, but contains: {stdout_content}"
            
            # Verify all messages are in stderr
            assert "Info message" in stderr_content
            assert "Warning message" in stderr_content
            assert "Error message" in stderr_content
            assert "Critical message" in stderr_content
        
        finally:
            # Restore original streams
            sys.stdout = original_stdout
            sys.stderr = original_stderr
    
    def test_exception_logging_with_stack_trace(self):
        """Test exception logging with stack traces"""
        # Create mock stderr
        mock_stderr = io.StringIO()
        
        # Create a test logger
        test_logger = logging.getLogger('test_exception_logger')
        test_logger.setLevel(logging.ERROR)
        test_logger.handlers = []
        
        # Add handler for stderr
        handler = logging.StreamHandler(mock_stderr)
        handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        test_logger.addHandler(handler)
        
        # Simulate exception logging
        try:
            raise ValueError("Test exception")
        except ValueError as e:
            test_logger.error(f"Internal error: {e}", exc_info=True)
        
        # Verify exception and stack trace are in stderr
        stderr_content = mock_stderr.getvalue()
        assert "Internal error" in stderr_content
        assert "Test exception" in stderr_content
        assert "Traceback" in stderr_content or "ValueError" in stderr_content
    
    def test_logging_configuration_from_config(self):
        """Test logging configuration from ServerConfig"""
        # Create config with different log levels
        for log_level in ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']:
            config = ServerConfig(log_level=log_level)
            
            # Verify log level is set correctly
            assert config.log_level == log_level
            
            # Verify it can be applied to logger
            test_logger = logging.getLogger(f'test_config_logger_{log_level}')
            test_logger.setLevel(config.log_level.upper())
            
            # Verify the level is set
            assert test_logger.level == getattr(logging, log_level)


class TestComponentLogging:
    """Unit tests for logging in specific components"""
    
    def test_socket_handler_logging(self):
        """Test SocketHandler logs to stderr"""
        # Create a string buffer to capture logs
        log_capture = io.StringIO()
        
        # Create a handler that writes to our buffer
        test_handler = logging.StreamHandler(log_capture)
        test_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        
        # Add handler to the logger temporarily
        logger.addHandler(test_handler)
        original_level = logger.level
        logger.setLevel(logging.DEBUG)
        
        try:
            # Create SocketHandler (will log initialization)
            handler = SocketHandler(host='localhost', port=8080)
            
            # Get log content
            log_content = log_capture.getvalue()
            
            # Verify initialization logging
            assert 'SocketHandler initialized' in log_content or \
                   'localhost:8080' in log_content, \
                   f"Expected initialization log, got: {log_content}"
        
        finally:
            # Remove test handler and restore level
            logger.removeHandler(test_handler)
            logger.setLevel(original_level)
    
    def test_oauth_manager_logging(self):
        """Test OAuthManager logs to stderr"""
        # Create a string buffer to capture logs
        log_capture = io.StringIO()
        
        # Create a handler that writes to our buffer
        test_handler = logging.StreamHandler(log_capture)
        test_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        
        # Add handler to the logger temporarily
        logger.addHandler(test_handler)
        original_level = logger.level
        logger.setLevel(logging.DEBUG)
        
        try:
            # Create OAuthManager (will log initialization)
            config = ServerConfig()
            manager = OAuthManager(config)
            
            # Get log content
            log_content = log_capture.getvalue()
            
            # Verify initialization logging
            assert 'OAuthManager initialized' in log_content, \
                   f"Expected initialization log, got: {log_content}"
        
        finally:
            # Remove test handler and restore level
            logger.removeHandler(test_handler)
            logger.setLevel(original_level)
    
    def test_stdio_handler_logging(self):
        """Test StdioHandler logs to stderr"""
        # Create a string buffer to capture logs
        log_capture = io.StringIO()
        
        # Create a handler that writes to our buffer
        test_handler = logging.StreamHandler(log_capture)
        test_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        
        # Add handler to the logger temporarily
        logger.addHandler(test_handler)
        original_level = logger.level
        logger.setLevel(logging.DEBUG)
        
        try:
            # Create StdioHandler (will log initialization)
            handler = StdioHandler()
            
            # Get log content
            log_content = log_capture.getvalue()
            
            # Verify initialization logging
            assert 'StdioHandler initialized' in log_content, \
                   f"Expected initialization log, got: {log_content}"
        
        finally:
            # Remove test handler and restore level
            logger.removeHandler(test_handler)
            logger.setLevel(original_level)


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
