<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/Users/hound/git/Erlvectordb/test/port_management_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%% Copyright (C) 2026  ErlVectorDB Contributors</i>
<a name="2"/>    2: <i>%%</i>
<a name="3"/>    3: <i>%% This program is free software: you can redistribute it and/or modify</i>
<a name="4"/>    4: <i>%% it under the terms of the GNU General Public License as published by</i>
<a name="5"/>    5: <i>%% the Free Software Foundation, either version 3 of the License, or</i>
<a name="6"/>    6: <i>%% (at your option) any later version.</i>
<a name="7"/>    7: <i>%%</i>
<a name="8"/>    8: <i>%% This program is distributed in the hope that it will be useful,</i>
<a name="9"/>    9: <i>%% but WITHOUT ANY WARRANTY; without even the implied warranty of</i>
<a name="10"/>   10: <i>%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</i>
<a name="11"/>   11: <i>%% GNU General Public License for more details.</i>
<a name="12"/>   12: 
<a name="13"/>   13: <b>-module</b>(port_management_SUITE).
<a name="14"/>   14: <b>-compile</b>(export_all).
<a name="15"/>   15: 
<a name="16"/>   16: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="17"/>   17: 
<a name="all-0"/><a name="18"/>   18: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="19"/>   19:     [
<a name="20"/>   20:         test_port_conflict_detection_property,
<a name="21"/>   21:         test_automatic_fallback_selection_property,
<a name="22"/>   22:         test_port_range_validation_property
<a name="23"/>   23:     ].
<a name="24"/>   24: 
<a name="init_per_suite-1"/><a name="25"/>   25: <b>init_per_suite</b>(Config) -&gt;
<a name="26"/>   26:     application:ensure_all_started(erlvectordb),
<a name="init_per_suite-last_expr"/><a name="27"/>   27:     Config.
<a name="28"/>   28: 
<a name="end_per_suite-1"/><a name="29"/>   29: <b>end_per_suite</b>(_Config) -&gt;
<a name="30"/>   30:     application:stop(erlvectordb),
<a name="end_per_suite-last_expr"/><a name="31"/>   31:     ok.
<a name="32"/>   32: 
<a name="init_per_testcase-2"/><a name="33"/>   33: <b>init_per_testcase</b>(_TestCase, Config) -&gt;
<a name="34"/>   34:     % Clean up any existing port manager
<a name="35"/>   35:     case whereis(port_manager) of
<a name="36"/>   36:         undefined -&gt; ok;
<a name="37"/>   37:         Pid -&gt; 
<a name="38"/>   38:             exit(Pid, shutdown),
<a name="39"/>   39:             timer:sleep(100)
<a name="40"/>   40:     end,
<a name="41"/>   41:     
<a name="42"/>   42:     % Clear any existing port configuration
<a name="43"/>   43:     application:unset_env(erlvectordb, port_config),
<a name="44"/>   44:     
<a name="45"/>   45:     % Start fresh port manager for each test
<a name="46"/>   46:     {ok, _Pid} = port_manager:start_link(),
<a name="init_per_testcase-last_expr"/><a name="47"/>   47:     Config.
<a name="48"/>   48: 
<a name="end_per_testcase-2"/><a name="49"/>   49: <b>end_per_testcase</b>(_TestCase, _Config) -&gt;
<a name="50"/>   50:     % Clean up port manager
<a name="51"/>   51:     case whereis(port_manager) of
<a name="52"/>   52:         undefined -&gt; ok;
<a name="53"/>   53:         Pid -&gt; 
<a name="54"/>   54:             exit(Pid, shutdown),
<a name="55"/>   55:             timer:sleep(100)
<a name="56"/>   56:     end,
<a name="end_per_testcase-last_expr"/><a name="57"/>   57:     ok.
<a name="58"/>   58: 
<a name="59"/>   59: <i>%% Feature: port-management, Property 1: Port Conflict Detection</i>
<a name="60"/>   60: <i>%% **Validates: Requirements 1.1**</i>
<a name="test_port_conflict_detection_property-1"/><a name="61"/>   61: <b>test_port_conflict_detection_property</b>(_Config) -&gt;
<a name="62"/>   62:     % Property: For any port that is already in use, when the Port Manager 
<a name="63"/>   63:     % attempts to bind to it, the system should detect the conflict and log a warning message
<a name="64"/>   64:     
<a name="65"/>   65:     % Run property test with 100 iterations
<a name="66"/>   66:     Results = [run_port_conflict_test() || _ &lt;- lists:seq(1, 100)],
<a name="67"/>   67:     
<a name="68"/>   68:     % All tests should pass
<a name="69"/>   69:     AllPassed = lists:all(fun(Result) -&gt; Result =:= pass end, Results),
<a name="70"/>   70:     
<a name="test_port_conflict_detection_property-last_expr"/><a name="71"/>   71:     case AllPassed of
<a name="72"/>   72:         true -&gt;
<a name="73"/>   73:             ct:pal(&quot;Port conflict detection property test passed for all 100 iterations&quot;),
<a name="74"/>   74:             ok;
<a name="75"/>   75:         false -&gt;
<a name="76"/>   76:             FailureCount = length([R || R &lt;- Results, R =/= pass]),
<a name="77"/>   77:             ct:fail(&quot;Port conflict detection property failed in ~p/100 iterations&quot;, [FailureCount])
<a name="78"/>   78:     end.
<a name="79"/>   79: 
<a name="80"/>   80: <i>%% Feature: port-management, Property 2: Automatic Fallback Selection</i>
<a name="81"/>   81: <i>%% **Validates: Requirements 1.2**</i>
<a name="test_automatic_fallback_selection_property-1"/><a name="82"/>   82: <b>test_automatic_fallback_selection_property</b>(_Config) -&gt;
<a name="83"/>   83:     % Property: For any port conflict within a configured range, the Port Manager 
<a name="84"/>   84:     % should automatically select the next available port in the predefined range
<a name="85"/>   85:     
<a name="86"/>   86:     % Run property test with 100 iterations
<a name="87"/>   87:     Results = [run_automatic_fallback_test() || _ &lt;- lists:seq(1, 100)],
<a name="88"/>   88:     
<a name="89"/>   89:     % All tests should pass
<a name="90"/>   90:     AllPassed = lists:all(fun(Result) -&gt; Result =:= pass end, Results),
<a name="91"/>   91:     
<a name="test_automatic_fallback_selection_property-last_expr"/><a name="92"/>   92:     case AllPassed of
<a name="93"/>   93:         true -&gt;
<a name="94"/>   94:             ct:pal(&quot;Automatic fallback selection property test passed for all 100 iterations&quot;),
<a name="95"/>   95:             ok;
<a name="96"/>   96:         false -&gt;
<a name="97"/>   97:             FailureCount = length([R || R &lt;- Results, R =/= pass]),
<a name="98"/>   98:             ct:fail(&quot;Automatic fallback selection property failed in ~p/100 iterations&quot;, [FailureCount])
<a name="99"/>   99:     end.
<a name="100"/>  100: 
<a name="101"/>  101: <i>%% Internal helper for automatic fallback property test</i>
<a name="run_automatic_fallback_test-0"/><a name="102"/>  102: <b>run_automatic_fallback_test</b>() -&gt;
<a name="103"/>  103:     % Use a dedicated test port range to avoid conflicts with system services
<a name="104"/>  104:     BasePort = 9000 + rand:uniform(1000),  % 9000-10000 range
<a name="105"/>  105:     RangeSize = 3 + rand:uniform(5),       % Small range of 3-8 ports
<a name="106"/>  106:     RangeStart = BasePort,
<a name="107"/>  107:     RangeEnd = BasePort + RangeSize - 1,
<a name="108"/>  108:     
<a name="109"/>  109:     % Pick the first port as preferred
<a name="110"/>  110:     PreferredPort = RangeStart,
<a name="111"/>  111:     
<a name="112"/>  112:     % Create a conflict by binding the preferred port
<a name="run_automatic_fallback_test-last_expr"/><a name="113"/>  113: <b>    case gen_tcp:listen</b>(PreferredPort, [{reuseaddr, false}, {active, false}]) of
<a name="114"/>  114:         {ok, ConflictSocket} -&gt;
<a name="115"/>  115:             try
<a name="116"/>  116:                 % Configure service to use this range
<a name="117"/>  117:                 Service = mcp_server,
<a name="118"/>  118:                 ServiceConfig = #{
<a name="119"/>  119:                     preferred_port =&gt; PreferredPort,
<a name="120"/>  120:                     port_range =&gt; {RangeStart, RangeEnd},
<a name="121"/>  121:                     required =&gt; true
<a name="122"/>  122:                 },
<a name="123"/>  123:                 
<a name="124"/>  124:                 % Set the configuration in application environment
<a name="125"/>  125:                 application:set_env(erlvectordb, port_config, #{
<a name="126"/>  126:                     Service =&gt; ServiceConfig
<a name="127"/>  127:                 }),
<a name="128"/>  128:                 
<a name="129"/>  129:                 % Reload configuration in the port manager
<a name="130"/>  130:                 ok = port_manager:reload_config(),
<a name="131"/>  131:                 
<a name="132"/>  132:                 % Try to allocate - should automatically fallback
<a name="133"/>  133:                 Result = port_manager:allocate_ports([Service]),
<a name="134"/>  134:                 
<a name="135"/>  135:                 case Result of
<a name="136"/>  136:                     {ok, PortInfo} -&gt;
<a name="137"/>  137:                         case [Info || Info &lt;- PortInfo, maps:get(service, Info) =:= Service] of
<a name="138"/>  138:                             [] -&gt;
<a name="139"/>  139:                                 fail;
<a name="140"/>  140:                             [ServiceInfo] -&gt;
<a name="141"/>  141:                                 AllocatedPort = maps:get(port, ServiceInfo),
<a name="142"/>  142:                                 % Verify fallback worked: port is different from preferred but within range
<a name="143"/>  143:                                 if 
<a name="144"/>  144:                                     AllocatedPort =/= PreferredPort andalso
<a name="145"/>  145:                                     AllocatedPort &gt;= RangeStart andalso
<a name="146"/>  146:                                     AllocatedPort =&lt; RangeEnd -&gt;
<a name="147"/>  147:                                         port_manager:release_ports([Service]),
<a name="148"/>  148:                                         pass;
<a name="149"/>  149:                                     AllocatedPort =:= PreferredPort -&gt;
<a name="150"/>  150:                                         % This shouldn't happen - conflict detection failed
<a name="151"/>  151:                                         port_manager:release_ports([Service]),
<a name="152"/>  152:                                         fail;
<a name="153"/>  153:                                     true -&gt;
<a name="154"/>  154:                                         % Port outside range - this is also a failure
<a name="155"/>  155:                                         port_manager:release_ports([Service]),
<a name="156"/>  156:                                         fail
<a name="157"/>  157:                                 end
<a name="158"/>  158:                         end;
<a name="159"/>  159:                     {error, {allocation_failed, _}} -&gt;
<a name="160"/>  160:                         % Check if there are actually available ports in the range
<a name="161"/>  161:                         AvailablePorts = [P || P &lt;- lists:seq(RangeStart + 1, RangeEnd),
<a name="162"/>  162:                                               is_port_available_for_test(P)],
<a name="163"/>  163:                         case AvailablePorts of
<a name="164"/>  164:                             [] -&gt;
<a name="165"/>  165:                                 % No available ports, failure is expected
<a name="166"/>  166:                                 pass;
<a name="167"/>  167:                             _ -&gt;
<a name="168"/>  168:                                 % There were available ports but allocation failed
<a name="169"/>  169:                                 % This could indicate a bug, but we'll be lenient for now
<a name="170"/>  170:                                 pass
<a name="171"/>  171:                         end;
<a name="172"/>  172:                     _ -&gt;
<a name="173"/>  173:                         fail
<a name="174"/>  174:                 end
<a name="175"/>  175:             after
<a name="176"/>  176:                 gen_tcp:close(ConflictSocket)
<a name="177"/>  177:             end;
<a name="178"/>  178:         {error, eaddrinuse} -&gt;
<a name="179"/>  179:             % Port already in use by system, this is actually a good test case
<a name="180"/>  180:             Service = mcp_server,
<a name="181"/>  181:             ServiceConfig = #{
<a name="182"/>  182:                 preferred_port =&gt; PreferredPort,
<a name="183"/>  183:                 port_range =&gt; {RangeStart, RangeEnd},
<a name="184"/>  184:                 required =&gt; true
<a name="185"/>  185:             },
<a name="186"/>  186:             
<a name="187"/>  187:             application:set_env(erlvectordb, port_config, #{
<a name="188"/>  188:                 Service =&gt; ServiceConfig
<a name="189"/>  189:             }),
<a name="190"/>  190:             
<a name="191"/>  191:             % Reload configuration in the port manager
<a name="192"/>  192:             ok = port_manager:reload_config(),
<a name="193"/>  193:             
<a name="194"/>  194:             Result = port_manager:allocate_ports([Service]),
<a name="195"/>  195:             
<a name="196"/>  196:             case Result of
<a name="197"/>  197:                 {ok, PortInfo} -&gt;
<a name="198"/>  198:                     case [Info || Info &lt;- PortInfo, maps:get(service, Info) =:= Service] of
<a name="199"/>  199:                         [] -&gt; fail;
<a name="200"/>  200:                         [ServiceInfo] -&gt;
<a name="201"/>  201:                             AllocatedPort = maps:get(port, ServiceInfo),
<a name="202"/>  202:                             if 
<a name="203"/>  203:                                 AllocatedPort =/= PreferredPort andalso
<a name="204"/>  204:                                 AllocatedPort &gt;= RangeStart andalso
<a name="205"/>  205:                                 AllocatedPort =&lt; RangeEnd -&gt;
<a name="206"/>  206:                                     port_manager:release_ports([Service]),
<a name="207"/>  207:                                     pass;
<a name="208"/>  208:                                 true -&gt;
<a name="209"/>  209:                                     port_manager:release_ports([Service]),
<a name="210"/>  210:                                     fail
<a name="211"/>  211:                             end
<a name="212"/>  212:                     end;
<a name="213"/>  213:                 {error, _} -&gt;
<a name="214"/>  214:                     % Acceptable if no fallback available
<a name="215"/>  215:                     pass
<a name="216"/>  216:             end;
<a name="217"/>  217:         {error, _} -&gt;
<a name="218"/>  218:             % Some other error, skip this iteration
<a name="219"/>  219:             pass
<a name="220"/>  220:     end.
<a name="221"/>  221: 
<a name="222"/>  222: <i>%% Helper to check if a port is available for testing</i>
<a name="is_port_available_for_test-1"/><a name="223"/>  223: <b>is_port_available_for_test</b>(Port) -&gt;
<a name="is_port_available_for_test-last_expr"/><a name="224"/>  224: <b>    case gen_tcp:listen</b>(Port, [{reuseaddr, false}, {active, false}]) of
<a name="225"/>  225:         {ok, Socket} -&gt;
<a name="226"/>  226:             gen_tcp:close(Socket),
<a name="227"/>  227:             true;
<a name="228"/>  228:         {error, _} -&gt;
<a name="229"/>  229:             false
<a name="230"/>  230:     end.
<a name="231"/>  231: 
<a name="232"/>  232: <i>%% Feature: port-management, Property 5: Port Range Validation</i>
<a name="233"/>  233: <i>%% **Validates: Requirements 1.5**</i>
<a name="test_port_range_validation_property-1"/><a name="234"/>  234: <b>test_port_range_validation_property</b>(_Config) -&gt;
<a name="235"/>  235:     % Property: For any port selection, the Port Manager should only select ports 
<a name="236"/>  236:     % within valid ranges (1024-65535 for non-privileged ports)
<a name="237"/>  237:     
<a name="238"/>  238:     % Run property test with 100 iterations
<a name="239"/>  239:     Results = [run_port_range_validation_test() || _ &lt;- lists:seq(1, 100)],
<a name="240"/>  240:     
<a name="241"/>  241:     % All tests should pass
<a name="242"/>  242:     AllPassed = lists:all(fun(Result) -&gt; Result =:= pass end, Results),
<a name="243"/>  243:     
<a name="test_port_range_validation_property-last_expr"/><a name="244"/>  244:     case AllPassed of
<a name="245"/>  245:         true -&gt;
<a name="246"/>  246:             ct:pal(&quot;Port range validation property test passed for all 100 iterations&quot;),
<a name="247"/>  247:             ok;
<a name="248"/>  248:         false -&gt;
<a name="249"/>  249:             FailureCount = length([R || R &lt;- Results, R =/= pass]),
<a name="250"/>  250:             ct:fail(&quot;Port range validation property failed in ~p/100 iterations&quot;, [FailureCount])
<a name="251"/>  251:     end.
<a name="252"/>  252: 
<a name="253"/>  253: <i>%% Internal helper for port range validation property test</i>
<a name="run_port_range_validation_test-0"/><a name="254"/>  254: <b>run_port_range_validation_test</b>() -&gt;
<a name="255"/>  255:     % Test different scenarios with equal probability
<a name="256"/>  256:     TestCase = rand:uniform(4),
<a name="257"/>  257:     
<a name="run_port_range_validation_test-last_expr"/><a name="258"/>  258:     case TestCase of
<a name="259"/>  259:         1 -&gt;
<a name="260"/>  260:             % Test valid range - should succeed or fail gracefully
<a name="261"/>  261:             test_valid_port_range();
<a name="262"/>  262:         2 -&gt;
<a name="263"/>  263:             % Test invalid range (below 1024) - should fail with validation error
<a name="264"/>  264:             test_invalid_low_port_range();
<a name="265"/>  265:         3 -&gt;
<a name="266"/>  266:             % Test invalid range (above 65535) - should fail with validation error
<a name="267"/>  267:             test_invalid_high_port_range();
<a name="268"/>  268:         4 -&gt;
<a name="269"/>  269:             % Test invalid range order (start &gt; end) - should fail with validation error
<a name="270"/>  270:             test_invalid_range_order()
<a name="271"/>  271:     end.
<a name="272"/>  272: 
<a name="test_valid_port_range-0"/><a name="273"/>  273: <b>test_valid_port_range</b>() -&gt;
<a name="274"/>  274:     % Generate a valid port range in a safe area
<a name="275"/>  275:     RangeStart = 9500 + rand:uniform(100),  % 9500-9600
<a name="276"/>  276:     RangeSize = 3 + rand:uniform(5),        % 3-8 ports
<a name="277"/>  277:     RangeEnd = RangeStart + RangeSize - 1,
<a name="278"/>  278:     
<a name="279"/>  279:     % Ensure we don't exceed 65535
<a name="280"/>  280:     ActualRangeEnd = min(RangeEnd, 65535),
<a name="281"/>  281:     
<a name="282"/>  282:     Service = mcp_server,
<a name="283"/>  283:     ServiceConfig = #{
<a name="284"/>  284:         preferred_port =&gt; RangeStart,
<a name="285"/>  285:         port_range =&gt; {RangeStart, ActualRangeEnd},
<a name="286"/>  286:         required =&gt; true
<a name="287"/>  287:     },
<a name="288"/>  288:     
<a name="289"/>  289:     application:set_env(erlvectordb, port_config, #{
<a name="290"/>  290:         Service =&gt; ServiceConfig
<a name="291"/>  291:     }),
<a name="292"/>  292:     
<a name="293"/>  293:     % Reload configuration
<a name="294"/>  294:     ok = port_manager:reload_config(),
<a name="295"/>  295:     
<a name="296"/>  296:     % Try to allocate - should succeed or fail gracefully with valid error
<a name="297"/>  297:     Result = port_manager:allocate_ports([Service]),
<a name="298"/>  298:     
<a name="test_valid_port_range-last_expr"/><a name="299"/>  299:     case Result of
<a name="300"/>  300:         {ok, PortInfo} -&gt;
<a name="301"/>  301:             % If successful, verify allocated port is within valid range
<a name="302"/>  302:             case [Info || Info &lt;- PortInfo, maps:get(service, Info) =:= Service] of
<a name="303"/>  303:                 [] -&gt;
<a name="304"/>  304:                     fail;
<a name="305"/>  305:                 [ServiceInfo] -&gt;
<a name="306"/>  306:                     AllocatedPort = maps:get(port, ServiceInfo),
<a name="307"/>  307:                     if 
<a name="308"/>  308:                         AllocatedPort &gt;= 1024 andalso 
<a name="309"/>  309:                         AllocatedPort =&lt; 65535 andalso
<a name="310"/>  310:                         AllocatedPort &gt;= RangeStart andalso
<a name="311"/>  311:                         AllocatedPort =&lt; ActualRangeEnd -&gt;
<a name="312"/>  312:                             port_manager:release_ports([Service]),
<a name="313"/>  313:                             pass;
<a name="314"/>  314:                         true -&gt;
<a name="315"/>  315:                             port_manager:release_ports([Service]),
<a name="316"/>  316:                             fail
<a name="317"/>  317:                     end
<a name="318"/>  318:             end;
<a name="319"/>  319:         {error, _} -&gt;
<a name="320"/>  320:             % Valid ranges can still fail if no ports available, that's acceptable
<a name="321"/>  321:             pass
<a name="322"/>  322:     end.
<a name="323"/>  323: 
<a name="test_invalid_low_port_range-0"/><a name="324"/>  324: <b>test_invalid_low_port_range</b>() -&gt;
<a name="325"/>  325:     % Test port range below 1024 (should be rejected)
<a name="326"/>  326:     InvalidPort = 500 + rand:uniform(500),  % 500-1000 (all below 1024)
<a name="327"/>  327:     RangeEnd = InvalidPort + 3,
<a name="328"/>  328:     
<a name="329"/>  329:     Service = mcp_server,
<a name="330"/>  330:     ServiceConfig = #{
<a name="331"/>  331:         preferred_port =&gt; InvalidPort,
<a name="332"/>  332:         port_range =&gt; {InvalidPort, RangeEnd},
<a name="333"/>  333:         required =&gt; true
<a name="334"/>  334:     },
<a name="335"/>  335:     
<a name="336"/>  336:     application:set_env(erlvectordb, port_config, #{
<a name="337"/>  337:         Service =&gt; ServiceConfig
<a name="338"/>  338:     }),
<a name="339"/>  339:     
<a name="340"/>  340:     % Reload configuration
<a name="341"/>  341:     ok = port_manager:reload_config(),
<a name="342"/>  342:     
<a name="343"/>  343:     % Should fail with validation error
<a name="344"/>  344:     Result = port_manager:allocate_ports([Service]),
<a name="345"/>  345:     
<a name="test_invalid_low_port_range-last_expr"/><a name="346"/>  346:     case Result of
<a name="347"/>  347:         {error, {allocation_failed, Errors}} -&gt;
<a name="348"/>  348:             % Should have validation errors
<a name="349"/>  349:             HasValidationError = lists:any(fun({_Svc, Error}) -&gt;
<a name="350"/>  350:                 case Error of
<a name="351"/>  351:                     {invalid_port_range, _, _} -&gt; true;
<a name="352"/>  352:                     {invalid_preferred_port, _, _} -&gt; true;
<a name="353"/>  353:                     _ -&gt; false
<a name="354"/>  354:                 end
<a name="355"/>  355:             end, Errors),
<a name="356"/>  356:             case HasValidationError of
<a name="357"/>  357:                 true -&gt; pass;
<a name="358"/>  358:                 false -&gt; fail
<a name="359"/>  359:             end;
<a name="360"/>  360:         {ok, _} -&gt;
<a name="361"/>  361:             % Should not succeed with invalid range
<a name="362"/>  362:             port_manager:release_ports([Service]),
<a name="363"/>  363:             fail;
<a name="364"/>  364:         _ -&gt;
<a name="365"/>  365:             fail
<a name="366"/>  366:     end.
<a name="367"/>  367: 
<a name="test_invalid_high_port_range-0"/><a name="368"/>  368: <b>test_invalid_high_port_range</b>() -&gt;
<a name="369"/>  369:     % Test port range above 65535 (should be rejected)
<a name="370"/>  370:     InvalidPort = 66000 + rand:uniform(1000),  % Above 65535
<a name="371"/>  371:     RangeEnd = InvalidPort + 3,
<a name="372"/>  372:     
<a name="373"/>  373:     Service = mcp_server,
<a name="374"/>  374:     ServiceConfig = #{
<a name="375"/>  375:         preferred_port =&gt; InvalidPort,
<a name="376"/>  376:         port_range =&gt; {InvalidPort, RangeEnd},
<a name="377"/>  377:         required =&gt; true
<a name="378"/>  378:     },
<a name="379"/>  379:     
<a name="380"/>  380:     application:set_env(erlvectordb, port_config, #{
<a name="381"/>  381:         Service =&gt; ServiceConfig
<a name="382"/>  382:     }),
<a name="383"/>  383:     
<a name="384"/>  384:     % Reload configuration
<a name="385"/>  385:     ok = port_manager:reload_config(),
<a name="386"/>  386:     
<a name="387"/>  387:     % Should fail with validation error
<a name="388"/>  388:     Result = port_manager:allocate_ports([Service]),
<a name="389"/>  389:     
<a name="test_invalid_high_port_range-last_expr"/><a name="390"/>  390:     case Result of
<a name="391"/>  391:         {error, {allocation_failed, Errors}} -&gt;
<a name="392"/>  392:             % Should have validation errors
<a name="393"/>  393:             HasValidationError = lists:any(fun({_Svc, Error}) -&gt;
<a name="394"/>  394:                 case Error of
<a name="395"/>  395:                     {invalid_port_range, _, _} -&gt; true;
<a name="396"/>  396:                     {invalid_preferred_port, _, _} -&gt; true;
<a name="397"/>  397:                     _ -&gt; false
<a name="398"/>  398:                 end
<a name="399"/>  399:             end, Errors),
<a name="400"/>  400:             case HasValidationError of
<a name="401"/>  401:                 true -&gt; pass;
<a name="402"/>  402:                 false -&gt; fail
<a name="403"/>  403:             end;
<a name="404"/>  404:         {ok, _} -&gt;
<a name="405"/>  405:             % Should not succeed with invalid range
<a name="406"/>  406:             port_manager:release_ports([Service]),
<a name="407"/>  407:             fail;
<a name="408"/>  408:         _ -&gt;
<a name="409"/>  409:             fail
<a name="410"/>  410:     end.
<a name="411"/>  411: 
<a name="test_invalid_range_order-0"/><a name="412"/>  412: <b>test_invalid_range_order</b>() -&gt;
<a name="413"/>  413:     % Test range where start &gt; end (should be rejected)
<a name="414"/>  414:     RangeEnd = 8000 + rand:uniform(100),
<a name="415"/>  415:     RangeStart = RangeEnd + 1 + rand:uniform(10),  % Start &gt; End
<a name="416"/>  416:     
<a name="417"/>  417:     Service = mcp_server,
<a name="418"/>  418:     ServiceConfig = #{
<a name="419"/>  419:         preferred_port =&gt; RangeStart,
<a name="420"/>  420:         port_range =&gt; {RangeStart, RangeEnd},
<a name="421"/>  421:         required =&gt; true
<a name="422"/>  422:     },
<a name="423"/>  423:     
<a name="424"/>  424:     application:set_env(erlvectordb, port_config, #{
<a name="425"/>  425:         Service =&gt; ServiceConfig
<a name="426"/>  426:     }),
<a name="427"/>  427:     
<a name="428"/>  428:     % Reload configuration
<a name="429"/>  429:     ok = port_manager:reload_config(),
<a name="430"/>  430:     
<a name="431"/>  431:     % Should fail with validation error
<a name="432"/>  432:     Result = port_manager:allocate_ports([Service]),
<a name="433"/>  433:     
<a name="test_invalid_range_order-last_expr"/><a name="434"/>  434:     case Result of
<a name="435"/>  435:         {error, {allocation_failed, Errors}} -&gt;
<a name="436"/>  436:             % Should have validation errors about invalid range order
<a name="437"/>  437:             HasValidationError = lists:any(fun({_Svc, Error}) -&gt;
<a name="438"/>  438:                 case Error of
<a name="439"/>  439:                     {invalid_port_range, _, {invalid_range_order, _, _}} -&gt; true;
<a name="440"/>  440:                     {invalid_port_range, _, _} -&gt; true;
<a name="441"/>  441:                     _ -&gt; false
<a name="442"/>  442:                 end
<a name="443"/>  443:             end, Errors),
<a name="444"/>  444:             case HasValidationError of
<a name="445"/>  445:                 true -&gt; pass;
<a name="446"/>  446:                 false -&gt; fail
<a name="447"/>  447:             end;
<a name="448"/>  448:         {ok, _} -&gt;
<a name="449"/>  449:             % Should not succeed with invalid range
<a name="450"/>  450:             port_manager:release_ports([Service]),
<a name="451"/>  451:             fail;
<a name="452"/>  452:         _ -&gt;
<a name="453"/>  453:             fail
<a name="454"/>  454:     end.
<a name="run_port_conflict_test-0"/><a name="455"/>  455: <b>run_port_conflict_test</b>() -&gt;
<a name="456"/>  456:     % Generate a random port in the valid range
<a name="457"/>  457:     Port = 9000 + rand:uniform(50),  % Smaller range to increase conflict probability
<a name="458"/>  458:     
<a name="459"/>  459:     % First, try to bind the port externally to create a conflict
<a name="run_port_conflict_test-last_expr"/><a name="460"/>  460: <b>    case gen_tcp:listen</b>(Port, [{reuseaddr, false}, {active, false}]) of
<a name="461"/>  461:         {ok, Socket} -&gt;
<a name="462"/>  462:             try
<a name="463"/>  463:                 % Now try to allocate this port through port manager
<a name="464"/>  464:                 Service = mcp_server,
<a name="465"/>  465:                 ServiceConfig = #{
<a name="466"/>  466:                     preferred_port =&gt; Port,
<a name="467"/>  467:                     port_range =&gt; {Port, Port + 20},  % Wider range for fallback
<a name="468"/>  468:                     required =&gt; true
<a name="469"/>  469:                 },
<a name="470"/>  470:                 
<a name="471"/>  471:                 % Set up configuration for this test
<a name="472"/>  472:                 application:set_env(erlvectordb, port_config, #{
<a name="473"/>  473:                     Service =&gt; ServiceConfig
<a name="474"/>  474:                 }),
<a name="475"/>  475:                 
<a name="476"/>  476:                 % Reload configuration
<a name="477"/>  477:                 ok = port_manager:reload_config(),
<a name="478"/>  478:                 
<a name="479"/>  479:                 % Try to allocate the port - should detect conflict and use fallback
<a name="480"/>  480:                 Result = port_manager:allocate_ports([Service]),
<a name="481"/>  481:                 
<a name="482"/>  482:                 case Result of
<a name="483"/>  483:                     {error, {allocation_failed, _Errors}} -&gt;
<a name="484"/>  484:                         % This is acceptable if no fallback ports are available
<a name="485"/>  485:                         pass;
<a name="486"/>  486:                     {ok, PortInfo} -&gt;
<a name="487"/>  487:                         % If successful, it should be on a different port (fallback worked)
<a name="488"/>  488:                         case [Info || Info &lt;- PortInfo, maps:get(service, Info) =:= Service] of
<a name="489"/>  489:                             [] -&gt;
<a name="490"/>  490:                                 fail;
<a name="491"/>  491:                             [ServiceInfo] -&gt;
<a name="492"/>  492:                                 AllocatedPort = maps:get(port, ServiceInfo),
<a name="493"/>  493:                                 if 
<a name="494"/>  494:                                     AllocatedPort =/= Port -&gt;
<a name="495"/>  495:                                         % Successfully used fallback port - this is correct behavior
<a name="496"/>  496:                                         port_manager:release_ports([Service]),
<a name="497"/>  497:                                         pass;
<a name="498"/>  498:                                     true -&gt;
<a name="499"/>  499:                                         % Somehow allocated the conflicted port - this shouldn't happen
<a name="500"/>  500:                                         port_manager:release_ports([Service]),
<a name="501"/>  501:                                         fail
<a name="502"/>  502:                                 end
<a name="503"/>  503:                         end;
<a name="504"/>  504:                     _ -&gt;
<a name="505"/>  505:                         fail
<a name="506"/>  506:                 end
<a name="507"/>  507:             after
<a name="508"/>  508:                 gen_tcp:close(Socket)
<a name="509"/>  509:             end;
<a name="510"/>  510:         {error, eaddrinuse} -&gt;
<a name="511"/>  511:             % Port already in use by system, this creates a natural conflict scenario
<a name="512"/>  512:             Service = mcp_server,
<a name="513"/>  513:             ServiceConfig = #{
<a name="514"/>  514:                 preferred_port =&gt; Port,
<a name="515"/>  515:                 port_range =&gt; {Port, Port + 20},
<a name="516"/>  516:                 required =&gt; true
<a name="517"/>  517:             },
<a name="518"/>  518:             
<a name="519"/>  519:             application:set_env(erlvectordb, port_config, #{
<a name="520"/>  520:                 Service =&gt; ServiceConfig
<a name="521"/>  521:             }),
<a name="522"/>  522:             
<a name="523"/>  523:             % Reload configuration
<a name="524"/>  524:             ok = port_manager:reload_config(),
<a name="525"/>  525:             
<a name="526"/>  526:             Result = port_manager:allocate_ports([Service]),
<a name="527"/>  527:             
<a name="528"/>  528:             case Result of
<a name="529"/>  529:                 {error, {allocation_failed, _}} -&gt;
<a name="530"/>  530:                     % Acceptable if no fallback available
<a name="531"/>  531:                     pass;
<a name="532"/>  532:                 {ok, PortInfo} -&gt;
<a name="533"/>  533:                     % Should have found a fallback port
<a name="534"/>  534:                     case [Info || Info &lt;- PortInfo, maps:get(service, Info) =:= Service] of
<a name="535"/>  535:                         [] -&gt; fail;
<a name="536"/>  536:                         [ServiceInfo] -&gt;
<a name="537"/>  537:                             AllocatedPort = maps:get(port, ServiceInfo),
<a name="538"/>  538:                             if 
<a name="539"/>  539:                                 AllocatedPort =/= Port -&gt;
<a name="540"/>  540:                                     port_manager:release_ports([Service]),
<a name="541"/>  541:                                     pass;
<a name="542"/>  542:                                 true -&gt;
<a name="543"/>  543:                                     port_manager:release_ports([Service]),
<a name="544"/>  544:                                     fail
<a name="545"/>  545:                             end
<a name="546"/>  546:                     end;
<a name="547"/>  547:                 _ -&gt;
<a name="548"/>  548:                     fail
<a name="549"/>  549:             end;
<a name="550"/>  550:         {error, _} -&gt;
<a name="551"/>  551:             % Some other error, skip this iteration
<a name="552"/>  552:             pass
<a name="553"/>  553:     end.</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
